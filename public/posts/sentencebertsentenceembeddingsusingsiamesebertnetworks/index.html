<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧 | Flowey &amp; Code</title>
<meta name="keywords" content="text-similarity">
<meta name="description" content="🚧目前進度:Deepl全文翻譯🚧">
<meta name="author" content="">
<link rel="canonical" href="https://lin-roger.github.io/posts/sentencebertsentenceembeddingsusingsiamesebertnetworks/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1cf1dcff6f1b1b62a9a6089dbbad72128582e20d09fb2d1f545347d17bb2f20c.css" integrity="sha256-HPHc/28bG2Kppgidu61yEoWC4g0J&#43;y0fVFNH0Xuy8gw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lin-roger.github.io/flowey.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lin-roger.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lin-roger.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lin-roger.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lin-roger.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>
<meta property="og:title" content="🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧" />
<meta property="og:description" content="🚧目前進度:Deepl全文翻譯🚧" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lin-roger.github.io/posts/sentencebertsentenceembeddingsusingsiamesebertnetworks/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-03T16:55:24+08:00" />
<meta property="article:modified_time" content="2023-07-03T16:55:24+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧"/>
<meta name="twitter:description" content="🚧目前進度:Deepl全文翻譯🚧"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lin-roger.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧",
      "item": "https://lin-roger.github.io/posts/sentencebertsentenceembeddingsusingsiamesebertnetworks/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧",
  "name": "🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧",
  "description": "🚧目前進度:Deepl全文翻譯🚧",
  "keywords": [
    "text-similarity"
  ],
  "articleBody": "Abstract BERT（Devlin等人，2018）和RoBERTa（Liu等人，2019）在语义文本相似性（STS）等句对回归任务上创造了新的最先进性能。然而，它需要将两个句子都送入网络，这造成了大量的计算开销：在10,000个句子的集合中找到最相似的一对，需要用BERT进行大约5千万次推理计算（约65小时）。BERT的构造使得它不适合于语义相似性搜索以及像聚类这样的无监督任务。\n在这份出版物中，我们提出了Sentence-BERT（SBERT），这是对预训练的BERT网络的修改，使用连体和三连体网络结构来得出有语义的句子嵌入，可以使用余弦相似度进行比较。这将寻找最相似对的努力从BERT/RoBERTa的65小时减少到SBERT的约5秒，同时保持BERT的准确性。\n我们在常见的STS任务和转移学习任务上对SBERT和SRoBERTa进行了评估，它的表现超过了其他最先进的句子嵌入方法。\n1 Introduction 在本出版物中，我们提出了Sentence-BERT（SBERT），这是一种使用连体和三连体网络对BERT网络的修改，能够得出有语义的句子嵌入2。这使得BERT能够用于某些新的任务，而这些任务到现在为止还不适用于BERT。这些任务包括大规模的语义相似性比较、聚类和通过语义搜索进行信息检索。\nBERT在各种句子分类和句对回归任务上创造了新的最先进的性能。BERT使用一个交叉编码器：两个句子被传递给变换器网络，并预测目标值。然而，由于可能的组合太多，这种设置不适合于各种对回归任务。在n = 10 000个句子的集合中找到相似度最高的一对，需要用BERT进行n-(n-1)/2 = 49 995 000次推理计算。 在现代V100 GPU上，这需要大约65小时。类似地，在Quora的4000多万个现有问题中找到与一个新问题最相似的问题，可以用BERT建模为一对一的比较，然而，回答一个查询需要50多个小时。\n解决聚类和语义搜索的常见方法是将每个句子映射到一个矢量空间，使语义相似的句子接近。研究人员已经开始将单个句子输入BERT，并得出固定大小的句子嵌入。最常用的方法是对BERT输出层进行平均化（称为BERT嵌入）或通过使用第一个标记（[CLS]标记）的输出。正如我们将表明的那样，这种常见的做法产生的句子嵌入相当糟糕，往往比平均GloVe嵌入更糟糕（Pennington等人，2014）。\n为了缓解这一问题，我们开发了SBERT。连体网络结构使输入句子的固定大小向量可以被导出。使用像余弦相似性或曼哈顿/欧几里得距离这样的相似性措施，可以找到语义上相似的句子。这些相似度测量可以在现代硬件上极其有效地进行，使SBERT可以用于语义相似度搜索以及聚类。在10,000个句子的集合中寻找最相似的句子对的复杂性从使用BERT的65小时减少到计算10,000个句子的嵌入（使用SBERT约5秒）和计算余弦相似度（约0.01秒）。通过使用优化的索引结构，寻找最相似的Quora问题可以从50小时减少到几毫秒（Johnson等人，2017）。\n我们在NLI数据上对SBERT进行了微调，它创建的句子嵌入明显优于其他最先进的句子嵌入方法，如InferSent（Conneau等人，2017）和Universal Sentence Encoder（Cer等人，2018）。在七个语义文本相似性（STS）任务上，SBERT与InferSent相比实现了11.7分的改进，与Universal Sentence Encoder相比实现了5.5分。在句子嵌入的评估工具包SentEval（Conneau和Kiela，2018）上，我们分别实现了2.1和2.6分的改进。\nSBERT可以适应特定的任务。它在一个具有挑战性的论据相似性数据集（Misra等人，2016年）和一个用于区分维基百科文章不同部分的句子的三联体数据集（Dor等人，2018年）上创造了新的最先进的性能。\n本文结构如下：第3节介绍了SBERT，第4节在常见的STS任务和具有挑战性的Argument Facet Similarity（AFS）语料库（Misra等人，2016）上评估了SBERT。第5节在SentEval上评估了SBERT。在第6节，我们进行了一项消融研究，以测试SBERT的一些设计方面。在第7节，我们比较了SBERT句子嵌入的计算效率与其他最先进的句子嵌入方法的对比。\n2 Related Work 我们首先介绍了BERT，然后，我们讨论了目前最先进的句子嵌入方法。\nBERT（Devlin等人，2018）是一个预训练的变换器网络（Vaswani等人，2017），它为各种NLP任务设置了新的最先进的结果，包括问题回答、句子分类和句对回归。用于句对回归的BERT的输入由两个句子组成，由一个特殊的[SEP]标记分开。在12层（基础模型）或24层（大型模型）上应用多头关注，输出被传递给一个简单的回归函数，以得出最终的标签。使用这种设置，BERT在语义文本相似度（STS）基准上创造了新的最先进的性能（Cer等人，2017）。RoBERTa（Liu等人，2019）表明，BERT的性能可以通过对预训练过程的小调整来进一步提高。我们还测试了XLNet（Yang等人，2019），但它总体上导致的结果比BERT更差。\nBERT网络结构的一个很大的缺点是没有计算独立的句子嵌入，这使得从BERT得出句子嵌入变得很困难。为了绕过这一限制，研究人员通过BERT传递单个句子，然后通过平均输出（类似于平均词嵌入）或使用特殊CLS标记的输出，得出一个固定大小的向量（例如：May等人（2019）；Zhang等人（2019）；Qiao等人（2019））。 这两个选项也是由流行的bert-as-a-service-repository3提供。据我们所知，到目前为止，还没有评估这些方法是否会导致有用的句子嵌入。\n句子嵌入是一个研究得很好的领域，有几十种提议的方法。Skip-Thought（Kiros等人，2015）训练一个编码器-解码器架构来预测周围的句子。 InferSent（Conneau等人，2017）使用斯坦福自然语言推理数据集（Bowman等人，2015）和MultiGenre NLI数据集（Williams等人，2018）的标记数据来训练一个连体BiLSTM网络，对输出进行最大池化。Conneau等人的研究表明，InferSent一直优于SkipThought等无监督方法。Universal Sentence Encoder（Cer等人，2018）训练了一个转化器网络，并通过SNLI的训练增强了无监督学习。Hill等人（2016）表明，训练句子嵌入的任务对其质量有很大影响。之前的工作（Conneau等人，2017；Cer等人，2018）发现，SNLI数据集适合训练句子嵌入。Yang等人（2018）提出了一种使用连体DAN和连体变换器网络对Reddit的对话进行训练的方法，在STS基准数据集上取得了良好的效果。\nHumeau等人（2019）解决了来自BERT的交叉编码器的运行时间开销，并提出了一种方法（poly-encoders）来计算m个语境向量和使用注意力的预计算的候选嵌入之间的得分。这个想法对于在更大的集合中寻找最高得分的句子是有效的。然而，多编码器有一个缺点，即分数函数不是对称的，而且对于像聚类这样的用例来说，计算开销太大，这需要$O(n^2)$的分数计算。\n以前的神经句子嵌入方法是从随机初始化开始训练的。 在本出版物中，我们使用预先训练好的BERT和RoBERTa网络，只对其进行微调以产生有用的句子嵌入。这大大减少了所需的训练时间：SBERT可以在不到20分钟内完成调整，同时产生比同类句子嵌入方法更好的结果。\n3 Model SBERT在BERT/RoBERTa的输出上增加了一个池化操作，以得出一个固定大小的句子嵌入。我们试验了三种池化策略：使用CLS-token的输出，计算所有输出向量的平均值（MEANstrategy），以及计算输出向量的最大超时（MAX-strategy）。默认配置是MEAN。\n为了微调BERT / RoBERTa，我们创建了连体和三连体网络（Schroff等人，2015），以更新权重，使产生的句子嵌入具有语义，可以用余弦相似度进行比较。\n网络结构取决于可用的训练数据。我们试验了以下结构和目标函数。\n图1：具有分类目标函数的SBERT结构，例如，用于SNLI数据集的微调。 两个BERT网络具有并列的权重（连体网络结构）。\n分类目标函数。 我们将句子嵌入$u$和$v$的元素之差$|u-v|$连接起来，并与可训练权重$W_t∈R^{3n×k}$相乘：\n$$o = \\text{softmax}(W_t(u, v, |u − v|))$$\n其中n是句子嵌入的维度，k是标签的数量。我们优化交叉熵损失。这个结构在图1中被描述出来。\n图2：推理时的SBERT架构，例如，计算相似性分数。这个架构也用于回归的目标函数。\n回归目标函数。 两个句子嵌入$u$和$v$之间的余弦相似度被计算出来（图2）。我们使用均方误差损失作为目标函数。\n三重目标函数。 给定一个锚点句子$a$，一个正面句子$p$和一个负面句子$n$，triplet loss调整网络，使$a$和$p$之间的距离小于$a$和$n$之间的距离：\n$$max(||s_a − s_p|| − ||s_a − s_n|| + \\epsilon, 0)$$\n$s_x$是$a/n/p$的句子嵌入，$|| \\cdot ||$是距离度量和余量$\\epsilon$。余量$\\epsilon$确保$s_p$至少比$s_n$更接近$s_a$。作为度量，我们使用欧氏距离，在我们的实验中，我们设定$\\epsilon =1$。\n3.1 Training Details 我们在SNLI（Bowman等人，2015）和Multi-Genre NLI（Williams等人，2018）数据集的组合上训练SBERT。SNLI是一个由57万个句子对组成的集合，注释了矛盾、缩略语和中性标签。MultiNLI包含430,000个句子对，涵盖了一系列的口语和书面文本的体裁。我们用3个软分类器的目标函数对SBERT进行了微调。我们使用了16个批次，学习率为2e-5的Adam优化器，以及10%的训练数据的线性学习率预热。我们默认的池化策略是MEAN。\n4 Evaluation - Semantic Textual Similarity 我们评估了SBERT在常见的语义文本相似性（STS）任务中的表现。 最先进的方法通常学习一个（复杂的）回归函数，将句子嵌入映射到相似性分数。相反，我们总是使用余弦相似度来比较两个句子嵌入之间的相似度。我们还用负曼哈顿和负欧几里得距离作为相似度测量方法进行了实验，但所有方法的结果都大致相同。\n表1：在各种文本相似性（STS）任务中，句子表征的余弦相似性和黄金标签之间的Spearman等级相关$ρ$。性能按惯例报告为$ρ×100$。STS12-STS16: SemEval 2012-2016, STSb：STSbenchmark, SICK-R: SICK relatedness dataset.\n4.1 Unsupervised STS 我们在不使用任何STS特定训练数据的情况下评估了SBERT在STS中的表现。我们使用2012-2016年的STS任务（Agirre等人，2012，2013，2014，2015，2016），STS基准（Cer等人，2017），以及SICK-Relatedness数据集（Marelli等人，2014）。这些数据集在句子对的语义相关度上提供了0到5的标签。我们在（Reimers等人，2016）中表明，皮尔逊相关度很不适合STS。相反，我们计算了句子嵌入的余弦相似度和黄金标签之间的Spearman等级相关。其他句子嵌入方法的设置是等同的，相似度是通过余弦相似度计算的。结果见表1\n结果显示，直接使用BERT的输出会导致相当差的性能。对BERT嵌入的平均数只达到了54.81的平均相关度，而使用CLStoken输出只达到了29.19的平均相关度。两者都比计算GloVe的平均嵌入要差。\n使用所描述的连体网络结构和微调机制大大改善了相关性，大大超过了InferSent和Universal Sentence Encoder的表现。SBERT表现比Universal Sentence Encoder差的唯一数据集是SICK-R。Universal Sentence Encoder是在各种数据集上训练的，包括新闻、问答页和讨论区，这似乎更适合SICK-R的数据。相比之下，SBERT只在维基百科（通过BERT）和NLI数据上进行了预训练。\n虽然RoBERTa能够提高几个监督任务的性能，但我们只观察到SBERT和SRoBERTa在生成句子嵌入方面的微小差异。\n表2：对STS基准测试集的评估。 BERT系统用10个随机种子和4个epochs训练。SBERT在STSb数据集上进行了微调，SBERT-NLI在NLI数据集上进行了预训练，然后在STSb数据集上进行了微调。\n4.2 Supervised STS STS基准（STSb）（Cer等人，2017）提供是一个流行的数据集，用于评估有监督的STS系统。该数据包括来自标题、新闻和论坛三个类别的8,628个句子对。它被分为训练（5,749）、设计（1,500）和测试（1,379）。BERT在这个数据集上创造了新的最先进的性能，它将两个句子都传给了网络，并对输出使用了简单的回归方法。\n我们使用训练集，利用回归目标函数对SBERT进行微调。在预测时，我们计算句子嵌入之间的余弦相似度。所有系统都是用10个随机种子进行训练，以对抗变异（Reimers和Gurevych，2018）。\n结果在表2中描述。我们对两种设置进行了实验：只在STSb上训练，以及先在NLI上训练，然后在STSb上训练。我们观察到，后来的策略导致了1-2分的轻微改善。这种两步法对BERT交叉编码器的影响特别大，它的性能提高了3-4个点。我们没有观察到BERT和RoBERTa之间的显著差异\n表3：Argument Facet Similarity（AFS）语料库的平均皮尔逊相关性r和平均斯皮尔曼等级相关性ρ（Misra等人，2016）。Misra等人提议进行10倍交叉验证。我们还在一个跨主题的情况下进行评估：方法在两个主题上训练，并在第三个主题上进行评估。\n4.3 Argument Facet Similarity 我们在Misra等人（2016）的Argument Facet Similarity（AFS）语料库上评估SBERT。AFS语料库注释了来自社交媒体对话的6,000个句子论据对，涉及三个有争议的话题：枪支管制、同性恋婚姻和死刑。这些数据被注释为从0（“不同的话题”）到5（“完全等同”）的等级。AFS语料库中的相似性概念与SemEval的STS数据集中的相似性概念相当不同。STS数据通常是描述性的，而AFS数据是对话中的争论性摘录。要被认为是相似的，论据不仅要提出相似的主张，而且要提供相似的推理。此外，AFS中的句子之间的词汇差距要大得多。因此，简单的无监督方法以及最先进的STS系统在这个数据集上表现很差（Reimers等人，2019）。\n我们在两种情况下对该数据集的SBERT进行评估：1）正如Misra等人所建议的，我们使用10倍交叉验证来评估SBERT。这种评估设置的一个缺点是，不清楚方法对不同主题的概括性如何。因此，2）我们在一个跨主题的设置中评估SBERT。两个主题用于训练，方法在被遗漏的主题上被评估。我们对所有三个主题重复这一过程，并对结果进行平均。\nSBERT使用回归目标函数进行微调。相似性得分是使用基于句子嵌入的余弦相似性来计算的。我们还提供了皮尔逊相关r，以使结果与Misra等人的结果相媲美。然而，我们表明（Reimers等人，2016），皮尔逊相关有一些严重的缺点，应该避免用于比较STS系统。结果在表3中描述。\n像tf-idf、平均GloVe嵌入或InferSent这样的无监督方法在这个数据集上表现得相当糟糕，得分很低。在10倍交叉验证设置中训练SBERT，其性能几乎与BERT相当。\n然而，在跨主题的评估中，我们观察到SBERT的性能下降了大约7点Spearman相关性。要被认为是相似的，论据应该针对相同的主张，并提供相同的推理。BERT能够使用注意力来直接比较两个句子（例如逐字比较），而SBERT必须将单个句子从一个未见过的主题映射到一个向量空间，从而使具有类似主张和理由的论点接近。这是一个更具挑战性的任务，它似乎需要超过两个主题的训练，才能与BERT的工作相提并论。\n表4：对维基百科部分三联体数据集的评估（Dor等人，2018）。用三联体损失训练的SBERT为一个 epoch\n4.4 Wikipedia Sections Distinction Dor等人（2018年）使用维基百科为句子嵌入方法创建了一个主题上细化的训练、设计和测试集。维基百科的文章被分成不同的部分，专注于某些方面。Dor等人认为，同一章节的句子在主题上比不同章节的句子更接近。他们利用这一点创建了一个大型的弱标记句子三联体数据集：锚和正面例子来自同一章节，而负面例子来自同一文章的不同章节。例如，来自Alice Arnold的文章：锚点：阿诺德在1988年加入了BBC广播剧团，正面：阿诺德在2012年5月获得了媒体的关注。，负面的：鲍丁和阿诺德都是热衷于业余高尔夫的人。\n我们使用Dor等人的数据集。我们使用三联体目标，在大约180万个训练三联体上训练SBERT一个历时，并在222,957个测试三联体上评估它。测试三联体来自维基百科的一个独特的文章集。作为评估指标，我们使用准确性：正面例子是否比负面例子更接近锚点？\n结果见表4。Dor等人微调了一个具有三倍损失的BiLSTM架构，以得出该数据集的句子嵌入。如表所示，SBERT明显优于Dor等人的BiLSTM方法。\n5 Evaluation - SentEval SentEval（Conneau和Kiela，2018）是一个流行的工具包，用于评估句子嵌入的质量。句子嵌入被用作逻辑回归分类器的特征。逻辑回归分类器在10倍交叉验证设置中对各种任务进行训练，并对测试倍数的预测准确性进行计算。\nSBERT句子嵌入的目的不是为了用于其他任务的转移学习。在这里，我们认为Devlin等人（2018）为新任务描述的微调BERT是更合适的方法，因为它更新了BERT网络的所有层。然而，SentEval仍然可以对我们的句子嵌入在各种任务中的质量给出印象。\n我们在以下七个SentEval转移任务上将SBERT的句子嵌入与其他句子嵌入方法进行比较：\nMR：对电影评论片段的情绪预测，以五级为起点（Pang and Lee, 2005）。 CR：顾客产品评论的情绪预测（Hu and Liu, 2004）。 SUBJ：对电影评论和情节摘要中的句子进行主观性预测（Pang and Lee, 2004）。 MPQA：来自新闻网的短语级意见极性分类（Wiebe等人，2005）。 SST：具有二进制标签的斯坦福情感树库（Socher等人，2013）。 TREC：来自TREC的细粒度问题类型分类（Li and Roth, 2002）。 MRPC：来自平行新闻源的微软研究院转述语料库（Dolan等人，2004）。 表5：使用SentEval工具包对SBERT句子嵌入的评估。SentEval通过训练一个以句子嵌入为特征的逻辑回归分类器，在不同的句子分类任务中评估句子嵌入。分数是基于10倍的交叉验证。\n结果可以在表5中找到。SBERT能够在7个任务中的5个任务中取得最佳性能。与InferSent以及Universal Sentence Encoder相比，平均性能提高了约2个百分点。 尽管转移学习不是SBERT的目的，但它在这项任务上超过了其他最先进的句子嵌入方法。\n看来，SBERT的句子嵌入很好地捕捉了情感信息：与InferSent和Universal Sentence Encoder相比，我们观察到SentEval对所有情感任务（MR、CR和SST）都有很大的改进。\nSBERT明显比Universal Sentence Encoder差的唯一数据集是TREC数据集。通用句子编码器在问题回答数据上进行了预训练，这对于TREC数据集的问题类型分类任务似乎是有益的。\n平均BERT嵌入或使用BERT网络的CLStoken输出在各种STS任务中取得了不好的结果（表1），比平均GloVe嵌入更差。然而，对于SentEval，平均BERT嵌入和BERT CLS-token输出取得了不错的结果（表5），超过了平均GloVe嵌入。 其原因是不同的设置。对于STS任务，我们使用余弦相似度来估计句子嵌入之间的相似性。余弦相似度对所有维度都是平等的。相比之下，SentEval将逻辑回归分类器用于句子嵌入。这使得某些维度对分类结果的影响有高有低。\n我们的结论是，BERT的平均嵌入/CLS-token输出返回的句子嵌入不可能与余弦相似性或曼哈顿/欧氏距离一起使用。 对于转移学习，它们产生的结果比InferSent或通用句子编码器略差。然而，在NLI数据集上使用所描述的具有连体网络结构的微调设置，产生的句子嵌入达到了SentEval工具箱的新的先进水平。\n6 Ablation Study 我们已经为SBERT句子嵌入的质量证明了强有力的经验结果。在本节中，我们对SBERT的不同方面进行了消减研究，以便更好地了解其相对重要性。\n我们评估了不同的集合策略（MEAN、MAX和CLS）。对于分类目标函数，我们评估了不同的连接方法。对于每个可能的配置，我们用10个不同的随机种子训练SBERT，并对其性能进行平均。\n目标函数（分类与回归）取决于注释的数据集。对于分类目标函数，我们在SNLI和Multi-NLI数据集上训练SBERTbase。对于回归目标函数，我们在STS基准数据集的训练集上进行训练。性能是在STS基准数据集的开发部分测量的。结果显示在表6中。\n表6：用分类目标函数在NLI数据上训练的SBERT，用回归目标函数在STS基准（STSb）上训练的SBERT。配置是在STSb的开发集上使用余弦相似度和Spearman等级相关度进行评估的。对于串联方法，我们只报告使用MEAN集合策略的得分。\n当用NLI数据的分类目标函数进行训练时，集合策略的影响相当小。串联模式的影响则大得多。InferSent（Conneau 3989等人，2017）和Universal Sentence Encoder（Cer等人，2018）都使用$(u, v, |u - v|, u ∗ v)$作为softmax分类器的输入。然而，在我们的架构中，添加e element-wise的$u ∗ v$降低了性能。\n最重要的部分是element-wise difference$|u - v|$。请注意，连接模式只与训练softmax分类器有关。在推理中，当预测STS基准数据集的相似性时，只使用句子嵌入$u$和$v$与余弦相似性相结合。element-wise difference衡量两个句子嵌入的维度之间的距离，确保相似的对更接近，不相似的对相距更远。\n当用回归目标函数进行训练时，我们发现集合策略有很大的影响。在这里，MAX策略的表现明显比MEAN或CLS-token策略差。这与（Conneau等人，2017）相反，他们发现InferSent的BiLSTM层使用MAX而不是MEAN池有好处。\n7 Computational Efficiency 句子嵌入有可能需要对数百万个句子进行计算，因此，需要高计算速度。在本节中，我们将SBERT与GloVe平均嵌入、InferSent（Conneau等人，2017）和Universal Sentence Encoder（Cer等人，2018）进行比较。\n对于我们的比较，我们使用STS基准的句子（Cer等人，2017）。我们使用一个简单的for-loop与python字典查询和NumPy计算平均GloVe嵌入。InferSent4是基于PyTorch的。对于Universal Sentence Encoder，我们使用TensorFlow Hub版本5，它是基于TensorFlow的。SBERT是基于PyTorch的。为了改进句子嵌入的计算，我们实施了一个智能批处理策略：这极大地减少了填充标记的计算开销。\n性能是在一台配备英特尔i7-5820K CPU @ 3.30GHz、Nvidia Tesla V100 GPU、CUDA 9.2和cuDNN的服务器上测量的。结果见表7。\n表7：句子嵌入方法的计算速度（每秒钟的句子）。越高越好。\n在CPU上，InferSent比SBERT快约65%。这是由于网络结构要简单得多。InferSent使用一个BiLSTM层，而BERT使用12个堆叠的变压器层。然而，变压器网络的一个优势是在GPU上的计算效率。在那里，带有智能批处理的SBERT比InferSent快约9%，比Universal Sentence Encoder快约55%。智能批处理在CPU上实现了89%的提速，在GPU上实现了48%的提速。平均GloVe嵌入显然在很大程度上是计算句子嵌入的最快方法。\n8 Conclusion 我们表明，BERT开箱即用，将句子映射到一个向量空间，而这个向量空间相当不适合与余弦相似性等常见的相似性措施一起使用。七个STS任务的性能低于GloVe平均嵌入的性能。\n为了克服这个缺点，我们提出了句子ERT（SBERT）。SBERT在一个连体/三连体网络结构中对BERT进行了微调。我们在各种常见的基准上评估了其质量，在那里它可以实现比最先进的句子嵌入方法的重大改进。在我们的实验中，用RoBERTa代替BERT并没有产生明显的改善。\nSBERT在计算上是高效的。在GPU上，它比InferSent快约9%，比Universal Sentence Encoder快约55%。SBERT可用于在计算上不可行的任务，用BERT建模。例如，用分层聚类法对10,000个句子进行聚类，用BERT需要大约65个小时，因为必须计算大约5000万个句子组合。使用SBERT，我们能够将这一努力减少到5秒左右。\n",
  "wordCount" : "246",
  "inLanguage": "en",
  "datePublished": "2023-07-03T16:55:24+08:00",
  "dateModified": "2023-07-03T16:55:24+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lin-roger.github.io/posts/sentencebertsentenceembeddingsusingsiamesebertnetworks/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Flowey \u0026 Code",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lin-roger.github.io/flowey.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lin-roger.github.io/" accesskey="h" title="flowey &amp; code (Alt + H)">
                <img src="https://lin-roger.github.io/flowey.png" alt="" aria-label="logo"
                    height="30">flowey &amp; code</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lin-roger.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lin-roger.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lin-roger.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lin-roger.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://lin-roger.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      🚧Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks🚧
    </h1>
    <div class="post-meta"><span title='2023-07-03 16:55:24 +0800 CST'>July 3, 2023</span>&nbsp;·&nbsp;2 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#abstract" aria-label="Abstract">Abstract</a></li>
                    <li>
                        <a href="#1-introduction" aria-label="1 Introduction">1 Introduction</a></li>
                    <li>
                        <a href="#2-related-work" aria-label="2 Related Work">2 Related Work</a></li>
                    <li>
                        <a href="#3-model" aria-label="3 Model">3 Model</a><ul>
                            
                    <li>
                        <a href="#31-training-details" aria-label="3.1 Training Details">3.1 Training Details</a></li></ul>
                    </li>
                    <li>
                        <a href="#4-evaluation---semantic-textual-similarity" aria-label="4 Evaluation - Semantic Textual Similarity">4 Evaluation - Semantic Textual Similarity</a><ul>
                            
                    <li>
                        <a href="#41-unsupervised-sts" aria-label="4.1 Unsupervised STS">4.1 Unsupervised STS</a></li>
                    <li>
                        <a href="#42-supervised-sts" aria-label="4.2 Supervised STS">4.2 Supervised STS</a></li>
                    <li>
                        <a href="#43-argument-facet-similarity" aria-label="4.3 Argument Facet Similarity">4.3 Argument Facet Similarity</a></li>
                    <li>
                        <a href="#44-wikipedia-sections-distinction" aria-label="4.4 Wikipedia Sections Distinction">4.4 Wikipedia Sections Distinction</a></li></ul>
                    </li>
                    <li>
                        <a href="#5-evaluation---senteval" aria-label="5 Evaluation - SentEval">5 Evaluation - SentEval</a></li>
                    <li>
                        <a href="#6-ablation-study" aria-label="6 Ablation Study">6 Ablation Study</a></li>
                    <li>
                        <a href="#7-computational-efficiency" aria-label="7 Computational Efficiency">7 Computational Efficiency</a></li>
                    <li>
                        <a href="#8-conclusion" aria-label="8 Conclusion">8 Conclusion</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="abstract">Abstract<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h2>
<p>BERT（Devlin等人，2018）和RoBERTa（Liu等人，2019）在语义文本相似性（STS）等句对回归任务上创造了新的最先进性能。然而，它需要将两个句子都送入网络，这造成了大量的计算开销：在10,000个句子的集合中找到最相似的一对，需要用BERT进行大约5千万次推理计算（约65小时）。BERT的构造使得它不适合于语义相似性搜索以及像聚类这样的无监督任务。</p>
<p>在这份出版物中，我们提出了Sentence-BERT（SBERT），这是对预训练的BERT网络的修改，使用连体和三连体网络结构来得出有语义的句子嵌入，可以使用余弦相似度进行比较。这将寻找最相似对的努力从BERT/RoBERTa的65小时减少到SBERT的约5秒，同时保持BERT的准确性。</p>
<p>我们在常见的STS任务和转移学习任务上对SBERT和SRoBERTa进行了评估，它的表现超过了其他最先进的句子嵌入方法。</p>
<h2 id="1-introduction">1 Introduction<a hidden class="anchor" aria-hidden="true" href="#1-introduction">#</a></h2>
<p>在本出版物中，我们提出了Sentence-BERT（SBERT），这是一种使用连体和三连体网络对BERT网络的修改，能够得出有语义的句子嵌入2。这使得BERT能够用于某些新的任务，而这些任务到现在为止还不适用于BERT。这些任务包括大规模的语义相似性比较、聚类和通过语义搜索进行信息检索。</p>
<p>BERT在各种句子分类和句对回归任务上创造了新的最先进的性能。BERT使用一个交叉编码器：两个句子被传递给变换器网络，并预测目标值。然而，由于可能的组合太多，这种设置不适合于各种对回归任务。在n = 10 000个句子的集合中找到相似度最高的一对，需要用BERT进行n-(n-1)/2 = 49 995 000次推理计算。 在现代V100 GPU上，这需要大约65小时。类似地，在Quora的4000多万个现有问题中找到与一个新问题最相似的问题，可以用BERT建模为一对一的比较，然而，回答一个查询需要50多个小时。</p>
<p>解决聚类和语义搜索的常见方法是将每个句子映射到一个矢量空间，使语义相似的句子接近。研究人员已经开始将单个句子输入BERT，并得出固定大小的句子嵌入。最常用的方法是对BERT输出层进行平均化（称为BERT嵌入）或通过使用第一个标记（[CLS]标记）的输出。正如我们将表明的那样，这种常见的做法产生的句子嵌入相当糟糕，往往比平均GloVe嵌入更糟糕（Pennington等人，2014）。</p>
<p>为了缓解这一问题，我们开发了SBERT。连体网络结构使输入句子的固定大小向量可以被导出。使用像余弦相似性或曼哈顿/欧几里得距离这样的相似性措施，可以找到语义上相似的句子。这些相似度测量可以在现代硬件上极其有效地进行，使SBERT可以用于语义相似度搜索以及聚类。在10,000个句子的集合中寻找最相似的句子对的复杂性从使用BERT的65小时减少到计算10,000个句子的嵌入（使用SBERT约5秒）和计算余弦相似度（约0.01秒）。通过使用优化的索引结构，寻找最相似的Quora问题可以从50小时减少到几毫秒（Johnson等人，2017）。</p>
<p>我们在NLI数据上对SBERT进行了微调，它创建的句子嵌入明显优于其他最先进的句子嵌入方法，如InferSent（Conneau等人，2017）和Universal Sentence Encoder（Cer等人，2018）。在七个语义文本相似性（STS）任务上，SBERT与InferSent相比实现了11.7分的改进，与Universal Sentence Encoder相比实现了5.5分。在句子嵌入的评估工具包SentEval（Conneau和Kiela，2018）上，我们分别实现了2.1和2.6分的改进。</p>
<p>SBERT可以适应特定的任务。它在一个具有挑战性的论据相似性数据集（Misra等人，2016年）和一个用于区分维基百科文章不同部分的句子的三联体数据集（Dor等人，2018年）上创造了新的最先进的性能。</p>
<p>本文结构如下：第3节介绍了SBERT，第4节在常见的STS任务和具有挑战性的Argument Facet Similarity（AFS）语料库（Misra等人，2016）上评估了SBERT。第5节在SentEval上评估了SBERT。在第6节，我们进行了一项消融研究，以测试SBERT的一些设计方面。在第7节，我们比较了SBERT句子嵌入的计算效率与其他最先进的句子嵌入方法的对比。</p>
<h2 id="2-related-work">2 Related Work<a hidden class="anchor" aria-hidden="true" href="#2-related-work">#</a></h2>
<p>我们首先介绍了BERT，然后，我们讨论了目前最先进的句子嵌入方法。</p>
<p>BERT（Devlin等人，2018）是一个预训练的变换器网络（Vaswani等人，2017），它为各种NLP任务设置了新的最先进的结果，包括问题回答、句子分类和句对回归。用于句对回归的BERT的输入由两个句子组成，由一个特殊的[SEP]标记分开。在12层（基础模型）或24层（大型模型）上应用多头关注，输出被传递给一个简单的回归函数，以得出最终的标签。使用这种设置，BERT在语义文本相似度（STS）基准上创造了新的最先进的性能（Cer等人，2017）。RoBERTa（Liu等人，2019）表明，BERT的性能可以通过对预训练过程的小调整来进一步提高。我们还测试了XLNet（Yang等人，2019），但它总体上导致的结果比BERT更差。</p>
<p>BERT网络结构的一个很大的缺点是没有计算独立的句子嵌入，这使得从BERT得出句子嵌入变得很困难。为了绕过这一限制，研究人员通过BERT传递单个句子，然后通过平均输出（类似于平均词嵌入）或使用特殊CLS标记的输出，得出一个固定大小的向量（例如：May等人（2019）；Zhang等人（2019）；Qiao等人（2019））。 这两个选项也是由流行的bert-as-a-service-repository3提供。据我们所知，到目前为止，还没有评估这些方法是否会导致有用的句子嵌入。</p>
<p>句子嵌入是一个研究得很好的领域，有几十种提议的方法。Skip-Thought（Kiros等人，2015）训练一个编码器-解码器架构来预测周围的句子。 InferSent（Conneau等人，2017）使用斯坦福自然语言推理数据集（Bowman等人，2015）和MultiGenre NLI数据集（Williams等人，2018）的标记数据来训练一个连体BiLSTM网络，对输出进行最大池化。Conneau等人的研究表明，InferSent一直优于SkipThought等无监督方法。Universal Sentence Encoder（Cer等人，2018）训练了一个转化器网络，并通过SNLI的训练增强了无监督学习。Hill等人（2016）表明，训练句子嵌入的任务对其质量有很大影响。之前的工作（Conneau等人，2017；Cer等人，2018）发现，SNLI数据集适合训练句子嵌入。Yang等人（2018）提出了一种使用连体DAN和连体变换器网络对Reddit的对话进行训练的方法，在STS基准数据集上取得了良好的效果。</p>
<p>Humeau等人（2019）解决了来自BERT的交叉编码器的运行时间开销，并提出了一种方法（poly-encoders）来计算m个语境向量和使用注意力的预计算的候选嵌入之间的得分。这个想法对于在更大的集合中寻找最高得分的句子是有效的。然而，多编码器有一个缺点，即分数函数不是对称的，而且对于像聚类这样的用例来说，计算开销太大，这需要$O(n^2)$的分数计算。</p>
<p>以前的神经句子嵌入方法是从随机初始化开始训练的。 在本出版物中，我们使用预先训练好的BERT和RoBERTa网络，只对其进行微调以产生有用的句子嵌入。这大大减少了所需的训练时间：SBERT可以在不到20分钟内完成调整，同时产生比同类句子嵌入方法更好的结果。</p>
<h2 id="3-model">3 Model<a hidden class="anchor" aria-hidden="true" href="#3-model">#</a></h2>
<p>SBERT在BERT/RoBERTa的输出上增加了一个池化操作，以得出一个固定大小的句子嵌入。我们试验了三种池化策略：使用CLS-token的输出，计算所有输出向量的平均值（MEANstrategy），以及计算输出向量的最大超时（MAX-strategy）。默认配置是MEAN。</p>
<p>为了微调BERT / RoBERTa，我们创建了连体和三连体网络（Schroff等人，2015），以更新权重，使产生的句子嵌入具有语义，可以用余弦相似度进行比较。</p>
<p>网络结构取决于可用的训练数据。我们试验了以下结构和目标函数。</p>
<p><img loading="lazy" src="figure1.png" alt="figure1"  />
</p>
<p>图1：具有分类目标函数的SBERT结构，例如，用于SNLI数据集的微调。 两个BERT网络具有并列的权重（连体网络结构）。</p>
<p><strong>分类目标函数。</strong> 我们将句子嵌入$u$和$v$的元素之差$|u-v|$连接起来，并与可训练权重$W_t∈R^{3n×k}$相乘：</p>
<p>$$o = \text{softmax}(W_t(u, v, |u − v|))$$</p>
<p>其中n是句子嵌入的维度，k是标签的数量。我们优化交叉熵损失。这个结构在图1中被描述出来。</p>
<p><img loading="lazy" src="figure2.png" alt="figure2"  />
</p>
<p>图2：推理时的SBERT架构，例如，计算相似性分数。这个架构也用于回归的目标函数。</p>
<p><strong>回归目标函数。</strong> 两个句子嵌入$u$和$v$之间的余弦相似度被计算出来（图2）。我们使用均方误差损失作为目标函数。</p>
<p><strong>三重目标函数。</strong> 给定一个锚点句子$a$，一个正面句子$p$和一个负面句子$n$，triplet loss调整网络，使$a$和$p$之间的距离小于$a$和$n$之间的距离：</p>
<p>$$max(||s_a − s_p|| − ||s_a − s_n|| + \epsilon, 0)$$</p>
<p>$s_x$是$a/n/p$的句子嵌入，$|| \cdot ||$是距离度量和余量$\epsilon$。余量$\epsilon$确保$s_p$至少比$s_n$更接近$s_a$。作为度量，我们使用欧氏距离，在我们的实验中，我们设定$\epsilon =1$。</p>
<h3 id="31-training-details">3.1 Training Details<a hidden class="anchor" aria-hidden="true" href="#31-training-details">#</a></h3>
<p>我们在SNLI（Bowman等人，2015）和Multi-Genre NLI（Williams等人，2018）数据集的组合上训练SBERT。SNLI是一个由57万个句子对组成的集合，注释了矛盾、缩略语和中性标签。MultiNLI包含430,000个句子对，涵盖了一系列的口语和书面文本的体裁。我们用3个软分类器的目标函数对SBERT进行了微调。我们使用了16个批次，学习率为2e-5的Adam优化器，以及10%的训练数据的线性学习率预热。我们默认的池化策略是MEAN。</p>
<h2 id="4-evaluation---semantic-textual-similarity">4 Evaluation - Semantic Textual Similarity<a hidden class="anchor" aria-hidden="true" href="#4-evaluation---semantic-textual-similarity">#</a></h2>
<p>我们评估了SBERT在常见的语义文本相似性（STS）任务中的表现。 最先进的方法通常学习一个（复杂的）回归函数，将句子嵌入映射到相似性分数。相反，我们总是使用余弦相似度来比较两个句子嵌入之间的相似度。我们还用负曼哈顿和负欧几里得距离作为相似度测量方法进行了实验，但所有方法的结果都大致相同。</p>
<p><img loading="lazy" src="table1.png" alt="table1"  />
</p>
<p>表1：在各种文本相似性（STS）任务中，句子表征的余弦相似性和黄金标签之间的Spearman等级相关$ρ$。性能按惯例报告为$ρ×100$。STS12-STS16: SemEval 2012-2016, STSb：STSbenchmark, SICK-R: SICK relatedness dataset.</p>
<h3 id="41-unsupervised-sts">4.1 Unsupervised STS<a hidden class="anchor" aria-hidden="true" href="#41-unsupervised-sts">#</a></h3>
<p>我们在不使用任何STS特定训练数据的情况下评估了SBERT在STS中的表现。我们使用2012-2016年的STS任务（Agirre等人，2012，2013，2014，2015，2016），STS基准（Cer等人，2017），以及SICK-Relatedness数据集（Marelli等人，2014）。这些数据集在句子对的语义相关度上提供了0到5的标签。我们在（Reimers等人，2016）中表明，皮尔逊相关度很不适合STS。相反，我们计算了句子嵌入的余弦相似度和黄金标签之间的Spearman等级相关。其他句子嵌入方法的设置是等同的，相似度是通过余弦相似度计算的。结果见表1</p>
<p>结果显示，直接使用BERT的输出会导致相当差的性能。对BERT嵌入的平均数只达到了54.81的平均相关度，而使用CLStoken输出只达到了29.19的平均相关度。两者都比计算GloVe的平均嵌入要差。</p>
<p>使用所描述的连体网络结构和微调机制大大改善了相关性，大大超过了InferSent和Universal Sentence Encoder的表现。SBERT表现比Universal Sentence Encoder差的唯一数据集是SICK-R。Universal Sentence Encoder是在各种数据集上训练的，包括新闻、问答页和讨论区，这似乎更适合SICK-R的数据。相比之下，SBERT只在维基百科（通过BERT）和NLI数据上进行了预训练。</p>
<p>虽然RoBERTa能够提高几个监督任务的性能，但我们只观察到SBERT和SRoBERTa在生成句子嵌入方面的微小差异。</p>
<p><img loading="lazy" src="table2.png" alt="table2"  />
</p>
<p>表2：对STS基准测试集的评估。 BERT系统用10个随机种子和4个epochs训练。SBERT在STSb数据集上进行了微调，SBERT-NLI在NLI数据集上进行了预训练，然后在STSb数据集上进行了微调。</p>
<h3 id="42-supervised-sts">4.2 Supervised STS<a hidden class="anchor" aria-hidden="true" href="#42-supervised-sts">#</a></h3>
<p>STS基准（STSb）（Cer等人，2017）提供是一个流行的数据集，用于评估有监督的STS系统。该数据包括来自标题、新闻和论坛三个类别的8,628个句子对。它被分为训练（5,749）、设计（1,500）和测试（1,379）。BERT在这个数据集上创造了新的最先进的性能，它将两个句子都传给了网络，并对输出使用了简单的回归方法。</p>
<p>我们使用训练集，利用回归目标函数对SBERT进行微调。在预测时，我们计算句子嵌入之间的余弦相似度。所有系统都是用10个随机种子进行训练，以对抗变异（Reimers和Gurevych，2018）。</p>
<p>结果在表2中描述。我们对两种设置进行了实验：只在STSb上训练，以及先在NLI上训练，然后在STSb上训练。我们观察到，后来的策略导致了1-2分的轻微改善。这种两步法对BERT交叉编码器的影响特别大，它的性能提高了3-4个点。我们没有观察到BERT和RoBERTa之间的显著差异</p>
<p><img loading="lazy" src="table3.png" alt="table3"  />
</p>
<p>表3：Argument Facet Similarity（AFS）语料库的平均皮尔逊相关性r和平均斯皮尔曼等级相关性ρ（Misra等人，2016）。Misra等人提议进行10倍交叉验证。我们还在一个跨主题的情况下进行评估：方法在两个主题上训练，并在第三个主题上进行评估。</p>
<h3 id="43-argument-facet-similarity">4.3 Argument Facet Similarity<a hidden class="anchor" aria-hidden="true" href="#43-argument-facet-similarity">#</a></h3>
<p>我们在Misra等人（2016）的Argument Facet Similarity（AFS）语料库上评估SBERT。AFS语料库注释了来自社交媒体对话的6,000个句子论据对，涉及三个有争议的话题：枪支管制、同性恋婚姻和死刑。这些数据被注释为从0（&ldquo;不同的话题&rdquo;）到5（&ldquo;完全等同&rdquo;）的等级。AFS语料库中的相似性概念与SemEval的STS数据集中的相似性概念相当不同。STS数据通常是描述性的，而AFS数据是对话中的争论性摘录。要被认为是相似的，论据不仅要提出相似的主张，而且要提供相似的推理。此外，AFS中的句子之间的词汇差距要大得多。因此，简单的无监督方法以及最先进的STS系统在这个数据集上表现很差（Reimers等人，2019）。</p>
<p>我们在两种情况下对该数据集的SBERT进行评估：1）正如Misra等人所建议的，我们使用10倍交叉验证来评估SBERT。这种评估设置的一个缺点是，不清楚方法对不同主题的概括性如何。因此，2）我们在一个跨主题的设置中评估SBERT。两个主题用于训练，方法在被遗漏的主题上被评估。我们对所有三个主题重复这一过程，并对结果进行平均。</p>
<p>SBERT使用回归目标函数进行微调。相似性得分是使用基于句子嵌入的余弦相似性来计算的。我们还提供了皮尔逊相关r，以使结果与Misra等人的结果相媲美。然而，我们表明（Reimers等人，2016），皮尔逊相关有一些严重的缺点，应该避免用于比较STS系统。结果在表3中描述。</p>
<p>像tf-idf、平均GloVe嵌入或InferSent这样的无监督方法在这个数据集上表现得相当糟糕，得分很低。在10倍交叉验证设置中训练SBERT，其性能几乎与BERT相当。</p>
<p>然而，在跨主题的评估中，我们观察到SBERT的性能下降了大约7点Spearman相关性。要被认为是相似的，论据应该针对相同的主张，并提供相同的推理。BERT能够使用注意力来直接比较两个句子（例如逐字比较），而SBERT必须将单个句子从一个未见过的主题映射到一个向量空间，从而使具有类似主张和理由的论点接近。这是一个更具挑战性的任务，它似乎需要超过两个主题的训练，才能与BERT的工作相提并论。</p>
<p><img loading="lazy" src="table4.png" alt="table4"  />
</p>
<p>表4：对维基百科部分三联体数据集的评估（Dor等人，2018）。用三联体损失训练的SBERT为一个 epoch</p>
<h3 id="44-wikipedia-sections-distinction">4.4 Wikipedia Sections Distinction<a hidden class="anchor" aria-hidden="true" href="#44-wikipedia-sections-distinction">#</a></h3>
<p>Dor等人（2018年）使用维基百科为句子嵌入方法创建了一个主题上细化的训练、设计和测试集。维基百科的文章被分成不同的部分，专注于某些方面。Dor等人认为，同一章节的句子在主题上比不同章节的句子更接近。他们利用这一点创建了一个大型的弱标记句子三联体数据集：锚和正面例子来自同一章节，而负面例子来自同一文章的不同章节。例如，来自Alice Arnold的文章：锚点：阿诺德在1988年加入了BBC广播剧团，正面：阿诺德在2012年5月获得了媒体的关注。，负面的：鲍丁和阿诺德都是热衷于业余高尔夫的人。</p>
<p>我们使用Dor等人的数据集。我们使用三联体目标，在大约180万个训练三联体上训练SBERT一个历时，并在222,957个测试三联体上评估它。测试三联体来自维基百科的一个独特的文章集。作为评估指标，我们使用准确性：正面例子是否比负面例子更接近锚点？</p>
<p>结果见表4。Dor等人微调了一个具有三倍损失的BiLSTM架构，以得出该数据集的句子嵌入。如表所示，SBERT明显优于Dor等人的BiLSTM方法。</p>
<h2 id="5-evaluation---senteval">5 Evaluation - SentEval<a hidden class="anchor" aria-hidden="true" href="#5-evaluation---senteval">#</a></h2>
<p>SentEval（Conneau和Kiela，2018）是一个流行的工具包，用于评估句子嵌入的质量。句子嵌入被用作逻辑回归分类器的特征。逻辑回归分类器在10倍交叉验证设置中对各种任务进行训练，并对测试倍数的预测准确性进行计算。</p>
<p>SBERT句子嵌入的目的不是为了用于其他任务的转移学习。在这里，我们认为Devlin等人（2018）为新任务描述的微调BERT是更合适的方法，因为它更新了BERT网络的所有层。然而，SentEval仍然可以对我们的句子嵌入在各种任务中的质量给出印象。</p>
<p>我们在以下七个SentEval转移任务上将SBERT的句子嵌入与其他句子嵌入方法进行比较：</p>
<ul>
<li>MR：对电影评论片段的情绪预测，以五级为起点（Pang and Lee, 2005）。</li>
<li>CR：顾客产品评论的情绪预测（Hu and Liu, 2004）。</li>
<li>SUBJ：对电影评论和情节摘要中的句子进行主观性预测（Pang and Lee, 2004）。</li>
<li>MPQA：来自新闻网的短语级意见极性分类（Wiebe等人，2005）。</li>
<li>SST：具有二进制标签的斯坦福情感树库（Socher等人，2013）。</li>
<li>TREC：来自TREC的细粒度问题类型分类（Li and Roth, 2002）。</li>
<li>MRPC：来自平行新闻源的微软研究院转述语料库（Dolan等人，2004）。</li>
</ul>
<p><img loading="lazy" src="table5.png" alt="table5"  />
</p>
<p>表5：使用SentEval工具包对SBERT句子嵌入的评估。SentEval通过训练一个以句子嵌入为特征的逻辑回归分类器，在不同的句子分类任务中评估句子嵌入。分数是基于10倍的交叉验证。</p>
<p>结果可以在表5中找到。SBERT能够在7个任务中的5个任务中取得最佳性能。与InferSent以及Universal Sentence Encoder相比，平均性能提高了约2个百分点。 尽管转移学习不是SBERT的目的，但它在这项任务上超过了其他最先进的句子嵌入方法。</p>
<p>看来，SBERT的句子嵌入很好地捕捉了情感信息：与InferSent和Universal Sentence Encoder相比，我们观察到SentEval对所有情感任务（MR、CR和SST）都有很大的改进。</p>
<p>SBERT明显比Universal Sentence Encoder差的唯一数据集是TREC数据集。通用句子编码器在问题回答数据上进行了预训练，这对于TREC数据集的问题类型分类任务似乎是有益的。</p>
<p>平均BERT嵌入或使用BERT网络的CLStoken输出在各种STS任务中取得了不好的结果（表1），比平均GloVe嵌入更差。然而，对于SentEval，平均BERT嵌入和BERT CLS-token输出取得了不错的结果（表5），超过了平均GloVe嵌入。 其原因是不同的设置。对于STS任务，我们使用余弦相似度来估计句子嵌入之间的相似性。余弦相似度对所有维度都是平等的。相比之下，SentEval将逻辑回归分类器用于句子嵌入。这使得某些维度对分类结果的影响有高有低。</p>
<p>我们的结论是，BERT的平均嵌入/CLS-token输出返回的句子嵌入不可能与余弦相似性或曼哈顿/欧氏距离一起使用。 对于转移学习，它们产生的结果比InferSent或通用句子编码器略差。然而，在NLI数据集上使用所描述的具有连体网络结构的微调设置，产生的句子嵌入达到了SentEval工具箱的新的先进水平。</p>
<h2 id="6-ablation-study">6 Ablation Study<a hidden class="anchor" aria-hidden="true" href="#6-ablation-study">#</a></h2>
<p>我们已经为SBERT句子嵌入的质量证明了强有力的经验结果。在本节中，我们对SBERT的不同方面进行了消减研究，以便更好地了解其相对重要性。</p>
<p>我们评估了不同的集合策略（MEAN、MAX和CLS）。对于分类目标函数，我们评估了不同的连接方法。对于每个可能的配置，我们用10个不同的随机种子训练SBERT，并对其性能进行平均。</p>
<p>目标函数（分类与回归）取决于注释的数据集。对于分类目标函数，我们在SNLI和Multi-NLI数据集上训练SBERTbase。对于回归目标函数，我们在STS基准数据集的训练集上进行训练。性能是在STS基准数据集的开发部分测量的。结果显示在表6中。</p>
<p><img loading="lazy" src="table6.png" alt="table6"  />
</p>
<p>表6：用分类目标函数在NLI数据上训练的SBERT，用回归目标函数在STS基准（STSb）上训练的SBERT。配置是在STSb的开发集上使用余弦相似度和Spearman等级相关度进行评估的。对于串联方法，我们只报告使用MEAN集合策略的得分。</p>
<p>当用NLI数据的分类目标函数进行训练时，集合策略的影响相当小。串联模式的影响则大得多。InferSent（Conneau 3989等人，2017）和Universal Sentence Encoder（Cer等人，2018）都使用$(u, v, |u - v|, u ∗ v)$作为softmax分类器的输入。然而，在我们的架构中，添加e element-wise的$u ∗ v$降低了性能。</p>
<p>最重要的部分是element-wise difference$|u - v|$。请注意，连接模式只与训练softmax分类器有关。在推理中，当预测STS基准数据集的相似性时，只使用句子嵌入$u$和$v$与余弦相似性相结合。element-wise difference衡量两个句子嵌入的维度之间的距离，确保相似的对更接近，不相似的对相距更远。</p>
<p>当用回归目标函数进行训练时，我们发现集合策略有很大的影响。在这里，MAX策略的表现明显比MEAN或CLS-token策略差。这与（Conneau等人，2017）相反，他们发现InferSent的BiLSTM层使用MAX而不是MEAN池有好处。</p>
<h2 id="7-computational-efficiency">7 Computational Efficiency<a hidden class="anchor" aria-hidden="true" href="#7-computational-efficiency">#</a></h2>
<p>句子嵌入有可能需要对数百万个句子进行计算，因此，需要高计算速度。在本节中，我们将SBERT与GloVe平均嵌入、InferSent（Conneau等人，2017）和Universal Sentence Encoder（Cer等人，2018）进行比较。</p>
<p>对于我们的比较，我们使用STS基准的句子（Cer等人，2017）。我们使用一个简单的for-loop与python字典查询和NumPy计算平均GloVe嵌入。InferSent4是基于PyTorch的。对于Universal Sentence Encoder，我们使用TensorFlow Hub版本5，它是基于TensorFlow的。SBERT是基于PyTorch的。为了改进句子嵌入的计算，我们实施了一个智能批处理策略：这极大地减少了填充标记的计算开销。</p>
<p>性能是在一台配备英特尔i7-5820K CPU @ 3.30GHz、Nvidia Tesla V100 GPU、CUDA 9.2和cuDNN的服务器上测量的。结果见表7。</p>
<p><img loading="lazy" src="table7.png" alt="table7"  />
</p>
<p>表7：句子嵌入方法的计算速度（每秒钟的句子）。越高越好。</p>
<p>在CPU上，InferSent比SBERT快约65%。这是由于网络结构要简单得多。InferSent使用一个BiLSTM层，而BERT使用12个堆叠的变压器层。然而，变压器网络的一个优势是在GPU上的计算效率。在那里，带有智能批处理的SBERT比InferSent快约9%，比Universal Sentence Encoder快约55%。智能批处理在CPU上实现了89%的提速，在GPU上实现了48%的提速。平均GloVe嵌入显然在很大程度上是计算句子嵌入的最快方法。</p>
<h2 id="8-conclusion">8 Conclusion<a hidden class="anchor" aria-hidden="true" href="#8-conclusion">#</a></h2>
<p>我们表明，BERT开箱即用，将句子映射到一个向量空间，而这个向量空间相当不适合与余弦相似性等常见的相似性措施一起使用。七个STS任务的性能低于GloVe平均嵌入的性能。</p>
<p>为了克服这个缺点，我们提出了句子ERT（SBERT）。SBERT在一个连体/三连体网络结构中对BERT进行了微调。我们在各种常见的基准上评估了其质量，在那里它可以实现比最先进的句子嵌入方法的重大改进。在我们的实验中，用RoBERTa代替BERT并没有产生明显的改善。</p>
<p>SBERT在计算上是高效的。在GPU上，它比InferSent快约9%，比Universal Sentence Encoder快约55%。SBERT可用于在计算上不可行的任务，用BERT建模。例如，用分层聚类法对10,000个句子进行聚类，用BERT需要大约65个小时，因为必须计算大约5000万个句子组合。使用SBERT，我们能够将这一努力减少到5秒左右。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lin-roger.github.io/tags/text-similarity/">text-similarity</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://lin-roger.github.io/posts/howcontextualarecontextualizedwordrepresentationscomparingthegeometryofbertelmoandgpt2embeddings/">
    <span class="title">Next »</span>
    <br>
    <span>🚧How Contextual are Contextualized Word Representations? Comparing the Geometry of BERT, ELMo, and GPT-2 Embeddings🚧</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
