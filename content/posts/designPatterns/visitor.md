---
title: "Visitor"
# summary: "文章介紹"
date: 2023-09-27T02:34:11+08:00
lastmod: 2023-09-27T02:34:11+08:00
# tags: 
# - prompt-engineering 
# - LLM

# cover:
#     image: "" #图片路径：posts/tech/文章1/picture.png
#     caption: "" #图片底部描述
#     alt: ""
#     relative: false

draft: true
# draft: false
---

## 主要功能

表示對物件結構中的元素執行的操作。Visitor令你可以在不更改被操作元素類別的條件下定義新的操作。

## 為何使用

考虑将程序表示为抽象语法树的编译器。编译器需要对抽象语法树进行操作，以进行 "静态语义 "分析，如检查是否定义了所有变量。编译器还需要生成代码。因此，它可能会定义类型检查、代码优化、流程分析、检查变量在使用前是否被赋值等操作。此外，我们还可以使用抽象语法树进行漂亮打印、程序重组、代码检测以及计算程序的各种指标。

这些操作大多需要区别对待表示赋值语句的节点和表示变量或算术表达式的节点。因此，赋值语句有一个类，变量访问有另一个类，算术表达式有另一个类，依此类推。当然，节点类的集合取决于编译的语言，但对于给定的语言来说变化不大。

<!-- Fig -->

该图显示了节点类层次结构的一部分。这里的问题是，将所有这些操作分布在不同的节点类中会导致系统难以理解、维护和更改。类型检查代码与漂亮打印代码或流程分析代码混杂在一起，会造成混乱。此外，添加一个新的操作通常需要重新编译所有这些类。如果每个新操作都能单独添加，而且节点类独立于适用于它们的操作，那就更好了。

我们可以将每个类中的相关操作打包到一个单独的对象（称为访问者）中，并在遍历抽象语法树时将其传递给抽象语法树中的元素，从而同时实现这两种功能。当一个元素 "接受 "访问者时，它就会向访问者发送一个请求，该请求编码了元素的类。请求中还包括作为参数的元素。然后，访问者将执行该元素的操作--也就是该元素类中的操作。

例如，不使用访问者的编译器可能会通过调用抽象语法树上的 TypeCheck 操作来对存储过程进行类型检查。每个节点都将通过在其组件上调用 TypeCheck 来实现 TypeCheck（见前面的类图）。如果编译器使用访问者对存储过程进行类型检查，那么它将创建一个 TypeCheckingVisitor 对象，并以该对象为参数在抽象语法树上调用 Accept 操作。每个节点都将通过回调访问者来实现 Accept：赋值节点调用访问者上的 VisitAssignment 操作，而变量引用则调用 VisitVariableReference。过去在类 AssignmentNode 中的 TypeCheck 操作现在是 TypeCheckingVisitor 上的 VisitAssignment 操作。

为了使访问者不仅仅用于类型检查，我们需要为抽象语法树的所有访问者建立一个抽象父类 NodeVisitor。NodeVisitor 必须为每个节点类声明一个操作。需要计算程序度量的应用程序将定义新的 NodeVisitor 子类，而不再需要在节点类中添加特定于应用程序的代码。访问者模式将每个编译阶段的操作封装在与该阶段相关联的访问者中。

使用访问者模式，您可以定义两个类层次结构：一个是被操作的元素（节点层次结构），另一个是定义元素操作的访问者（NodeVisitor 层次结构）。通过在访问者类层次结构中添加一个新的子类，就可以创建一个新的操作。只要编译器接受的语法不发生变化（也就是说，我们不必添加新的 Node 子类），我们就可以通过定义新的 NodeVisitor 子类来添加新的功能。

## 使用時機

* 一个对象结构包含许多具有不同接口的对象类，而你想对这些对象执行依赖于其具体类的操作。
* 在一个对象结构中，需要对对象执行许多不同的、互不相关的操作，而你又希望避免这些操作 "污染 "它们的类。Visitor 可以在一个类中定义相关操作，从而将这些操作集中在一起。当对象结构被许多应用程序共享时，可以使用 Visitor 将操作放在需要的应用程序中。
* 虽然定义对象结构的类很少发生变化，但我们经常需要对结构定义新的操作。更改对象结构类需要重新定义所有访问者的接口，这样做的代价可能会很高。如果对象结构类经常变化，那么最好在这些类中定义操作。
